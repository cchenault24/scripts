"""
Unit tests for lib/config.py.

Tests Continue.dev configuration generation and file operations.
"""

import json
import sys
from pathlib import Path
from unittest.mock import MagicMock, Mock, patch, mock_open

import pytest

sys.path.insert(0, str(Path(__file__).parent.parent))

from lib import config
from lib.hardware import HardwareInfo, HardwareTier
from lib.model_selector import RecommendedModel, ModelRole


# =============================================================================
# Fixtures
# =============================================================================

@pytest.fixture
def sample_models():
    """Sample models for config generation."""
    return [
        RecommendedModel(
            name="Qwen2.5 Coder 7B",
            ollama_name="qwen2.5-coder:7b",
            ram_gb=5.0,
            role=ModelRole.CHAT,
            roles=["chat", "edit"],
            description="Primary model"
        ),
        RecommendedModel(
            name="StarCoder2 3B",
            ollama_name="starcoder2:3b",
            ram_gb=2.0,
            role=ModelRole.AUTOCOMPLETE,
            roles=["autocomplete"],
            description="Autocomplete model"
        ),
        RecommendedModel(
            name="Nomic Embed",
            ollama_name="nomic-embed-text",
            ram_gb=0.3,
            role=ModelRole.EMBED,
            roles=["embed"],
            description="Embedding model"
        ),
    ]


# =============================================================================
# Config Generation Tests
# =============================================================================

class TestConfigGeneration:
    """Tests for Continue.dev config generation."""
    
    def test_normalize_model_recommended_model(self, sample_models):
        """Test normalizing RecommendedModel objects."""
        model = sample_models[0]
        normalized = config._normalize_model(model)
        
        assert isinstance(normalized, dict)
        # Check that the model was normalized (name field exists)
        assert "name" in normalized
        assert "roles" in normalized
    
    def test_normalize_model_dict(self):
        """Test normalizing dict model objects."""
        model_dict = {
            "name": "test-model",
            "ram_gb": 5.0,
            "roles": ["chat"]
        }
        normalized = config._normalize_model(model_dict)
        
        assert normalized["name"] == "test-model"
        assert normalized["ram_gb"] == 5.0


# =============================================================================
# Fingerprint Tests
# =============================================================================

class TestFingerprinting:
    """Tests for file fingerprinting functionality."""
    
    def test_add_fingerprint_header_yaml(self):
        """Test adding fingerprint to YAML content."""
        content = "models:\n  - name: test"
        result = config.add_fingerprint_header(content, "yaml")
        
        assert "Generated by" in result
        assert "ollama-llm-setup" in result
        assert content in result
    
    def test_add_fingerprint_header_md(self):
        """Test adding fingerprint to Markdown content."""
        content = "# Rules\n\nSome rules here."
        result = config.add_fingerprint_header(content, "md")
        
        assert "Generated by" in result
        assert content in result
    
    @patch('builtins.open', mock_open(read_data=b'test content'))
    def test_calculate_file_hash(self):
        """Test file hash calculation."""
        with patch('pathlib.Path.exists', return_value=True):
            file_hash = config.calculate_file_hash(Path("/test/file.txt"))
        
        # Should return a hash or empty string
        assert isinstance(file_hash, str)


# =============================================================================
# File Type Classification Tests
# =============================================================================

class TestFileClassification:
    """Tests for file type classification."""
    
    @pytest.mark.parametrize("filename,expected_contains", [
        ("config.yaml", "config"),
        ("config.json", "config"),
        ("global-rule.md", "rule"),
        (".continueignore", "ignore"),
        ("setup-summary.json", "summary"),
        ("unknown.txt", "other"),
    ])
    def test_classify_file_type(self, filename, expected_contains):
        """Test file type classification contains expected type."""
        path = Path(f"/test/{filename}")
        file_type = config.classify_file_type(path)
        
        # File type should contain the expected substring (e.g., "config_yaml" contains "config")
        assert expected_contains in file_type, f"{file_type} should contain {expected_contains}"


# =============================================================================
# Manifest Tests
# =============================================================================

class TestManifest:
    """Tests for installation manifest operations."""
    
    def test_load_manifest_not_found(self, tmp_path):
        """Test loading manifest when file doesn't exist."""
        manifest_path = tmp_path / ".continue" / "setup-manifest.json"
        
        with patch.object(Path, 'home', return_value=tmp_path):
            result = config.load_installation_manifest()
        
        assert result is None
    
    def test_load_manifest_success(self, tmp_path):
        """Test loading valid manifest."""
        continue_dir = tmp_path / ".continue"
        continue_dir.mkdir()
        
        manifest_data = {
            "version": "2.0",
            "timestamp": "2024-01-01T00:00:00Z",
            "installed": {"models": [], "files": []},
            "pre_existing": {"models": []}
        }
        manifest_path = continue_dir / "setup-manifest.json"
        manifest_path.write_text(json.dumps(manifest_data))
        
        with patch.object(Path, 'home', return_value=tmp_path):
            result = config.load_installation_manifest()
        
        assert result is not None
        assert result["version"] == "2.0"
    
    def test_load_manifest_corrupt(self, tmp_path):
        """Test loading corrupt manifest."""
        continue_dir = tmp_path / ".continue"
        continue_dir.mkdir()
        
        manifest_path = continue_dir / "setup-manifest.json"
        manifest_path.write_text("invalid json {{{")
        
        with patch.object(Path, 'home', return_value=tmp_path):
            result = config.load_installation_manifest()
        
        # Implementation returns None for corrupt files (logs warning)
        # This is acceptable behavior - caller should handle None
        assert result is None or result.get("_unreadable_manifest") is True


# =============================================================================
# Is Our File Tests
# =============================================================================

class TestIsOurFile:
    """Tests for detecting installer-generated files."""
    
    def test_is_our_file_with_fingerprint(self, tmp_path):
        """Test detecting file with installer fingerprint."""
        test_file = tmp_path / "config.yaml"
        content = config.add_fingerprint_header("test: content", "yaml")
        test_file.write_text(content)
        
        manifest = {"installed": {"files": []}}
        result = config.is_our_file(test_file, manifest)
        
        assert result is True
    
    def test_is_our_file_in_manifest(self, tmp_path):
        """Test detecting file listed in manifest."""
        test_file = tmp_path / "config.yaml"
        test_file.write_text("test: content")
        
        manifest = {
            "installed": {
                "files": [{"path": str(test_file)}]
            }
        }
        result = config.is_our_file(test_file, manifest)
        
        # Result can be True or "maybe" - both indicate the file might be ours
        assert result in [True, "maybe"], f"Expected True or 'maybe', got {result}"
    
    def test_is_our_file_not_ours(self, tmp_path):
        """Test detecting file that's not ours."""
        test_file = tmp_path / "config.yaml"
        test_file.write_text("test: content")  # No fingerprint
        
        manifest = {"installed": {"files": []}}
        result = config.is_our_file(test_file, manifest)
        
        assert result is False


# =============================================================================
# UTC Timestamp Tests
# =============================================================================

class TestTimestamps:
    """Tests for timestamp generation."""
    
    def test_get_utc_timestamp_format(self):
        """Test UTC timestamp format."""
        timestamp = config._get_utc_timestamp()
        
        # Should be ISO format with timezone
        assert "T" in timestamp
        assert "+" in timestamp or "Z" in timestamp
    
    def test_get_utc_timestamp_is_utc(self):
        """Test that timestamp is UTC."""
        from datetime import datetime, timezone
        
        timestamp = config._get_utc_timestamp()
        
        # Parse and verify it's a valid timestamp
        # Should not raise an exception
        assert len(timestamp) > 0


# =============================================================================
# Edge Cases
# =============================================================================

class TestEdgeCases:
    """Tests for edge cases and error handling."""
    
    def test_normalize_model_empty_roles(self):
        """Test normalizing model with empty roles."""
        model = RecommendedModel(
            name="Test",
            ollama_name="test:latest",
            ram_gb=1.0,
            role=ModelRole.CHAT,
            roles=[],
            description="Test"
        )
        normalized = config._normalize_model(model)
        
        assert normalized["roles"] == []
    
    def test_fingerprint_header_unknown_type(self):
        """Test fingerprint with unknown file type."""
        content = "some content"
        result = config.add_fingerprint_header(content, "unknown")
        
        # Should still return content
        assert content in result
    
    @patch('builtins.open')
    def test_calculate_file_hash_permission_error(self, mock_file):
        """Test hash calculation with permission error."""
        mock_file.side_effect = PermissionError("Access denied")
        
        with patch('pathlib.Path.exists', return_value=True):
            result = config.calculate_file_hash(Path("/test/file"))
        
        assert result == ""  # Should return empty string on error
